# Code generated by sqlc. DO NOT EDIT.
# versions:
#   sqlc v1.13.0
# source: global_notifications.sql
import datetime
import pydantic
from typing import AsyncIterator, List, Optional

import sqlalchemy
import sqlalchemy.ext.asyncio

from app.db.gen.queries import models


CHECK_HAS_NEW_GLOBAL_NOTIFICATIONS = """-- name: check_has_new_global_notifications \\:one
select
  exists (
    select
      1
    from
      global_notifications
    where
      updated_at > (
        select
          last_global_notification_at
        from
          users
        where
          user_id = :p1)
        and receiver_role = any (:p2\\:\\:role[])) as has_new_global_notifications
"""


class CheckHasNewGlobalNotificationsParams(pydantic.BaseModel):
    user_id: int
    roles: List[models.Role]


CREATE_GLOBAL_NOTIFICATION = """-- name: create_global_notification \\:one
insert into global_notifications (sender, receiver_role, title, body, LABEL, link)
  values (:p1, :p2, :p3, :p4, :p5, :p6)
returning
  global_notification_id, sender, receiver_role, title, body, label, link, created_at, updated_at
"""


class CreateGlobalNotificationParams(pydantic.BaseModel):
    sender: Optional[str]
    receiver_role: models.Role
    title: str
    body: str
    label: str
    link: Optional[str]


DELETE_GLOBAL_NOTIFICATION = """-- name: delete_global_notification \\:exec
delete from global_notifications
where global_notification_id = :p1
returning
  global_notification_id, sender, receiver_role, title, body, label, link, created_at, updated_at
"""


GET_GLOBAL_NOTIFICATIONS_BY_STARTING_DATE = """-- name: get_global_notifications_by_starting_date \\:many
select
  notifications.global_notification_id,
  notifications.sender,
  notifications.receiver_role,
  notifications.title,
  notifications.label,
  notifications.link,
  notifications.body,
  notifications.created_at,
  notifications.updated_at,
  notifications.event_timestamp,
  notifications.event_type\\:\\:event_type as event_type,
  ROW_NUMBER() over (order by event_timestamp desc) as "row_number"
from ((
    -- Rows where the notification has been updated at some point.
    select
      global_notification_id, sender, receiver_role, title, body, label, link, created_at, updated_at,
      updated_at as event_timestamp,
      -- define a new column event_type and set its value
      'is_update' as event_type
    from
      global_notifications
    where
      global_notifications.updated_at < :p1
      and receiver_role = any (:p2\\:\\:role[])
      and updated_at != created_at
    order by
      updated_at desc
    limit :p3\\:\\:int)
union (
  -- All rows.
  select
    global_notification_id, sender, receiver_role, title, body, label, link, created_at, updated_at,
    created_at as event_timestamp,
    -- define a new column event_type and set its value
    'is_create' as event_type
  from
    global_notifications
  where
    global_notifications.created_at < :p1
    and receiver_role = any (:p2\\:\\:role[])
  order by
    created_at desc
  limit :p3\\:\\:int)) as notifications
order by
  event_timestamp desc
limit :p3\\:\\:int
"""


class GetGlobalNotificationsByStartingDateParams(pydantic.BaseModel):
    starting_date: datetime.datetime
    roles: List[models.Role]
    page_chunk_size: Optional[int]


class GetGlobalNotificationsByStartingDateRow(pydantic.BaseModel):
    global_notification_id: int
    sender: Optional[str]
    receiver_role: models.Role
    title: str
    label: str
    link: Optional[str]
    body: str
    created_at: datetime.datetime
    updated_at: datetime.datetime
    event_timestamp: datetime.datetime
    event_type: models.EventType
    row_number: int


class AsyncQuerier:
    def __init__(self, conn: sqlalchemy.ext.asyncio.AsyncConnection):
        self._conn = conn

    async def check_has_new_global_notifications(self, arg: CheckHasNewGlobalNotificationsParams) -> Optional[bool]:
        row = (await self._conn.execute(sqlalchemy.text(CHECK_HAS_NEW_GLOBAL_NOTIFICATIONS), {"p1": arg.user_id, "p2": arg.roles})).first()
        if row is None:
            return None
        return row[0]

    async def create_global_notification(self, arg: CreateGlobalNotificationParams) -> Optional[models.GlobalNotification]:
        row = (await self._conn.execute(sqlalchemy.text(CREATE_GLOBAL_NOTIFICATION), {
            "p1": arg.sender,
            "p2": arg.receiver_role,
            "p3": arg.title,
            "p4": arg.body,
            "p5": arg.label,
            "p6": arg.link,
        })).first()
        if row is None:
            return None
        return models.GlobalNotification(
            global_notification_id=row[0],
            sender=row[1],
            receiver_role=row[2],
            title=row[3],
            body=row[4],
            label=row[5],
            link=row[6],
            created_at=row[7],
            updated_at=row[8],
        )

    async def delete_global_notification(self, *, global_notification_id: int) -> None:
        await self._conn.execute(sqlalchemy.text(DELETE_GLOBAL_NOTIFICATION), {"p1": global_notification_id})

    async def get_global_notifications_by_starting_date(self, arg: GetGlobalNotificationsByStartingDateParams) -> AsyncIterator[GetGlobalNotificationsByStartingDateRow]:
        result = await self._conn.stream(sqlalchemy.text(GET_GLOBAL_NOTIFICATIONS_BY_STARTING_DATE), {"p1": arg.starting_date, "p2": arg.roles, "p3": arg.page_chunk_size})
        async for row in result:
            yield GetGlobalNotificationsByStartingDateRow(
                global_notification_id=row[0],
                sender=row[1],
                receiver_role=row[2],
                title=row[3],
                label=row[4],
                link=row[5],
                body=row[6],
                created_at=row[7],
                updated_at=row[8],
                event_timestamp=row[9],
                event_type=row[10],
                row_number=row[11],
            )
