# Code generated by sqlc. DO NOT EDIT.
# versions:
#   sqlc v1.13.0
# source: users.sql
import datetime
import pydantic
from typing import Any, AsyncIterator, List, Optional

import sqlalchemy
import sqlalchemy.ext.asyncio

from app.db.gen.queries import models


GET_ROLES = """-- name: get_roles \\:many
select
  ENUM_RANGE(null\\:\\:users.role)\\:\\:text[]
"""


GET_USER = """-- name: get_user \\:one
select
  username,
  email,
  role,
  is_verified,
  is_active,
  is_superuser,
  last_global_notification_at,
  last_personal_notification_at,
  created_at,
  updated_at,
  full_name,
  phone_number,
  bio,
  image,
  COALESCE(
    case when :p1\\:\\:boolean then
      (user_id)
    end, -1)\\:\\:int as user_id,
  case when :p1\\:\\:boolean then
    (salt)
  end as salt,
  case when :p1\\:\\:boolean then
    (password)
  end as password
from
  users
  left join profiles using (user_id)
where (email = LOWER(:p2)\\:\\:text
  or :p2\\:\\:text is null)
and (username = :p3\\:\\:text
  or :p3\\:\\:text is null)
and (users.user_id = :p4\\:\\:int
  or :p4\\:\\:int is null)
limit 1
"""


class GetUserParams(pydantic.BaseModel):
    get_db_data: bool
    email: Optional[str]
    username: Optional[str]
    user_id: Optional[int]


class GetUserRow(pydantic.BaseModel):
    username: str
    email: str
    role: models.Role
    is_verified: bool
    is_active: bool
    is_superuser: bool
    last_global_notification_at: datetime.datetime
    last_personal_notification_at: datetime.datetime
    created_at: datetime.datetime
    updated_at: datetime.datetime
    full_name: Optional[str]
    phone_number: Optional[str]
    bio: Optional[str]
    image: Optional[str]
    user_id: int
    salt: Optional[Any]
    password: Optional[Any]


LIST_ALL_USERS = """-- name: list_all_users \\:many
select
  users.user_id,
  username,
  email,
  role,
  is_verified,
  salt,
  password,
  is_active,
  is_superuser,
  last_global_notification_at,
  last_personal_notification_at,
  created_at,
  updated_at
from
  users
  left join profiles using (user_id)
where
  is_verified = :p1\\:\\:boolean
  or :p1\\:\\:boolean is null
"""


REGISTER_NEW_USER = """-- name: register_new_user \\:one
insert into users (username, email, password, salt, is_superuser, is_verified)
  values (:p1, :p2, :p3, :p4, :p5, :p6)
returning
  user_id, username, email, role, is_verified, is_active, is_superuser,
    last_global_notification_at, last_personal_notification_at, created_at, updated_at
"""


class RegisterNewUserParams(pydantic.BaseModel):
    username: str
    email: str
    password: str
    salt: str
    is_superuser: bool
    is_verified: bool


class RegisterNewUserRow(pydantic.BaseModel):
    user_id: int
    username: str
    email: str
    role: models.Role
    is_verified: bool
    is_active: bool
    is_superuser: bool
    last_global_notification_at: datetime.datetime
    last_personal_notification_at: datetime.datetime
    created_at: datetime.datetime
    updated_at: datetime.datetime


RESET_USER_PASSWORD = """-- name: reset_user_password \\:exec
update
  users
set
  password = :p1,
  salt     = :p2
where
  email = LOWER(:p3)
"""


class ResetUserPasswordParams(pydantic.BaseModel):
    password: str
    salt: str
    email: str


UPDATE_GLOBAL_LAST_NOTIFICATION_AT = """-- name: update_global_last_notification_at \\:exec
update
  users
set
  last_global_notification_at = :p1
where
  user_id = :p2
"""


class UpdateGlobalLastNotificationAtParams(pydantic.BaseModel):
    last_global_notification_at: datetime.datetime
    user_id: int


UPDATE_PERSONAL_LAST_NOTIFICATION_AT = """-- name: update_personal_last_notification_at \\:exec
update
  users
set
  last_personal_notification_at = :p1
where
  user_id = :p2
"""


class UpdatePersonalLastNotificationAtParams(pydantic.BaseModel):
    last_personal_notification_at: datetime.datetime
    user_id: int


UPDATE_USER_BY_ID = """-- name: update_user_by_id \\:one
update
  users
set
  password = COALESCE(:p1, password),
  salt     = COALESCE(:p2, salt),
  username = COALESCE(:p3, username),
  email    = COALESCE(LOWER(:p4), email)
where
  user_id = :p5
returning
  user_id,
  username,
  email,
  role,
  is_verified,
  salt,
  password,
  is_active,
  is_superuser,
  last_global_notification_at,
  last_personal_notification_at,
  created_at,
  updated_at
"""


class UpdateUserByIdParams(pydantic.BaseModel):
    password: Optional[str]
    salt: Optional[str]
    username: Optional[str]
    email: Optional[str]
    user_id: int


UPDATE_USER_ROLE = """-- name: update_user_role \\:exec
update
  users
set
  role = :p1
where
  user_id = :p2
"""


class UpdateUserRoleParams(pydantic.BaseModel):
    role: models.Role
    user_id: int


VERIFY_USER_BY_EMAIL = """-- name: verify_user_by_email \\:one
update
  users
set
  is_verified = 'true'
where
  email = LOWER(:p1)
returning
  email
"""


class AsyncQuerier:
    def __init__(self, conn: sqlalchemy.ext.asyncio.AsyncConnection):
        self._conn = conn

    async def get_roles(self) -> AsyncIterator[List[str]]:
        result = await self._conn.stream(sqlalchemy.text(GET_ROLES))
        async for row in result:
            yield row[0]

    async def get_user(self, arg: GetUserParams) -> Optional[GetUserRow]:
        row = (await self._conn.execute(sqlalchemy.text(GET_USER), {
            "p1": arg.get_db_data,
            "p2": arg.email,
            "p3": arg.username,
            "p4": arg.user_id,
        })).first()
        if row is None:
            return None
        return GetUserRow(
            username=row[0],
            email=row[1],
            role=row[2],
            is_verified=row[3],
            is_active=row[4],
            is_superuser=row[5],
            last_global_notification_at=row[6],
            last_personal_notification_at=row[7],
            created_at=row[8],
            updated_at=row[9],
            full_name=row[10],
            phone_number=row[11],
            bio=row[12],
            image=row[13],
            user_id=row[14],
            salt=row[15],
            password=row[16],
        )

    async def list_all_users(self, *, is_verified: Optional[bool]) -> AsyncIterator[models.User]:
        result = await self._conn.stream(sqlalchemy.text(LIST_ALL_USERS), {"p1": is_verified})
        async for row in result:
            yield models.User(
                user_id=row[0],
                username=row[1],
                email=row[2],
                role=row[3],
                is_verified=row[4],
                salt=row[5],
                password=row[6],
                is_active=row[7],
                is_superuser=row[8],
                last_global_notification_at=row[9],
                last_personal_notification_at=row[10],
                created_at=row[11],
                updated_at=row[12],
            )

    async def register_new_user(self, arg: RegisterNewUserParams) -> Optional[RegisterNewUserRow]:
        row = (await self._conn.execute(sqlalchemy.text(REGISTER_NEW_USER), {
            "p1": arg.username,
            "p2": arg.email,
            "p3": arg.password,
            "p4": arg.salt,
            "p5": arg.is_superuser,
            "p6": arg.is_verified,
        })).first()
        if row is None:
            return None
        return RegisterNewUserRow(
            user_id=row[0],
            username=row[1],
            email=row[2],
            role=row[3],
            is_verified=row[4],
            is_active=row[5],
            is_superuser=row[6],
            last_global_notification_at=row[7],
            last_personal_notification_at=row[8],
            created_at=row[9],
            updated_at=row[10],
        )

    async def reset_user_password(self, arg: ResetUserPasswordParams) -> None:
        await self._conn.execute(sqlalchemy.text(RESET_USER_PASSWORD), {"p1": arg.password, "p2": arg.salt, "p3": arg.email})

    async def update_global_last_notification_at(self, arg: UpdateGlobalLastNotificationAtParams) -> None:
        await self._conn.execute(sqlalchemy.text(UPDATE_GLOBAL_LAST_NOTIFICATION_AT), {"p1": arg.last_global_notification_at, "p2": arg.user_id})

    async def update_personal_last_notification_at(self, arg: UpdatePersonalLastNotificationAtParams) -> None:
        await self._conn.execute(sqlalchemy.text(UPDATE_PERSONAL_LAST_NOTIFICATION_AT), {"p1": arg.last_personal_notification_at, "p2": arg.user_id})

    async def update_user_by_id(self, arg: UpdateUserByIdParams) -> Optional[models.User]:
        row = (await self._conn.execute(sqlalchemy.text(UPDATE_USER_BY_ID), {
            "p1": arg.password,
            "p2": arg.salt,
            "p3": arg.username,
            "p4": arg.email,
            "p5": arg.user_id,
        })).first()
        if row is None:
            return None
        return models.User(
            user_id=row[0],
            username=row[1],
            email=row[2],
            role=row[3],
            is_verified=row[4],
            salt=row[5],
            password=row[6],
            is_active=row[7],
            is_superuser=row[8],
            last_global_notification_at=row[9],
            last_personal_notification_at=row[10],
            created_at=row[11],
            updated_at=row[12],
        )

    async def update_user_role(self, arg: UpdateUserRoleParams) -> None:
        await self._conn.execute(sqlalchemy.text(UPDATE_USER_ROLE), {"p1": arg.role, "p2": arg.user_id})

    async def verify_user_by_email(self, *, email: str) -> Optional[str]:
        row = (await self._conn.execute(sqlalchemy.text(VERIFY_USER_BY_EMAIL), {"p1": email})).first()
        if row is None:
            return None
        return row[0]
