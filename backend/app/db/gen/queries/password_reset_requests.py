# Code generated by sqlc. DO NOT EDIT.
# versions:
#   sqlc v1.13.0
# source: password_reset_requests.sql
import pydantic
from typing import AsyncIterator, Optional

import sqlalchemy
import sqlalchemy.ext.asyncio

from app.db.gen.queries import models


CREATE_PASSWORD_RESET_REQUEST = """-- name: create_password_reset_request \\:one
insert into password_reset_requests (email, message)
  values (:p1\\:\\:text, :p2\\:\\:text)
returning
  password_reset_request_id, email, message, created_at, updated_at
"""


class CreatePasswordResetRequestParams(pydantic.BaseModel):
    email: str
    message: str


DELETE_PASSWORD_RESET_REQUEST = """-- name: delete_password_reset_request \\:one
delete from password_reset_requests
where password_reset_request_id = :p1
returning
  password_reset_request_id, email, message, created_at, updated_at
"""


GET_PASSWORD_RESET_REQUESTS = """-- name: get_password_reset_requests \\:many
select
  password_reset_request_id, email, message, created_at, updated_at
from
  password_reset_requests
"""


class AsyncQuerier:
    def __init__(self, conn: sqlalchemy.ext.asyncio.AsyncConnection):
        self._conn = conn

    async def create_password_reset_request(self, arg: CreatePasswordResetRequestParams) -> Optional[models.PasswordResetRequest]:
        row = (await self._conn.execute(sqlalchemy.text(CREATE_PASSWORD_RESET_REQUEST), {"p1": arg.email, "p2": arg.message})).first()
        if row is None:
            return None
        return models.PasswordResetRequest(
            password_reset_request_id=row[0],
            email=row[1],
            message=row[2],
            created_at=row[3],
            updated_at=row[4],
        )

    async def delete_password_reset_request(self, *, password_reset_request_id: int) -> Optional[models.PasswordResetRequest]:
        row = (await self._conn.execute(sqlalchemy.text(DELETE_PASSWORD_RESET_REQUEST), {"p1": password_reset_request_id})).first()
        if row is None:
            return None
        return models.PasswordResetRequest(
            password_reset_request_id=row[0],
            email=row[1],
            message=row[2],
            created_at=row[3],
            updated_at=row[4],
        )

    async def get_password_reset_requests(self) -> AsyncIterator[models.PasswordResetRequest]:
        result = await self._conn.stream(sqlalchemy.text(GET_PASSWORD_RESET_REQUESTS))
        async for row in result:
            yield models.PasswordResetRequest(
                password_reset_request_id=row[0],
                email=row[1],
                message=row[2],
                created_at=row[3],
                updated_at=row[4],
            )
