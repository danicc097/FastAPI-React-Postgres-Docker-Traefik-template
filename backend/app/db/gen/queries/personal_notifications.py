# Code generated by sqlc. DO NOT EDIT.
# versions:
#   sqlc v1.13.0
# source: personal_notifications.sql
import datetime
import pydantic
from typing import AsyncIterator, Optional

import sqlalchemy
import sqlalchemy.ext.asyncio

from app.db.gen.queries import models


CHECK_HAS_NEW_PERSONAL_NOTIFICATIONS = """-- name: check_has_new_personal_notifications \\:one
select
  exists (
    select
      1
    from
      personal_notifications
    where
      updated_at > (
        select
          last_personal_notification_at
        from
          users
        where
          email = :p1)
        and receiver_email = :p1) as has_new_notifications
"""


CREATE_PERSONAL_NOTIFICATION = """-- name: create_personal_notification \\:one
insert into personal_notifications (sender, receiver_email, title, body, LABEL, link)
  values (:p1, :p2, :p3, :p4, :p5, :p6)
returning
  personal_notification_id, sender, receiver_email, title, body, label, link, created_at, updated_at
"""


class CreatePersonalNotificationParams(pydantic.BaseModel):
    sender: Optional[str]
    receiver_email: str
    title: str
    body: str
    label: str
    link: Optional[str]


DELETE_PERSONAL_NOTIFICATION = """-- name: delete_personal_notification \\:exec
delete from personal_notifications
where personal_notification_id = :p1
returning
  personal_notification_id, sender, receiver_email, title, body, label, link, created_at, updated_at
"""


GET_PERSONAL_NOTIFICATION_BY_ID = """-- name: get_personal_notification_by_id \\:one
select
  personal_notification_id, sender, receiver_email, title, body, label, link, created_at, updated_at
from
  personal_notifications
where
  personal_notification_id = :p1
"""


GET_PERSONAL_NOTIFICATIONS_BY_STARTING_DATE = """-- name: get_personal_notifications_by_starting_date \\:many
select
  notifications.personal_notification_id,
  notifications.sender,
  notifications.receiver_email,
  notifications.title,
  notifications.label,
  notifications.link,
  notifications.body,
  notifications.created_at,
  notifications.updated_at,
  notifications.event_timestamp,
  notifications.event_type\\:\\:event_type as event_type,
  ROW_NUMBER() over (order by event_timestamp desc) as "row_number"
from ((
    -- Rows where the notification has been updated at some point.
    select
      personal_notification_id, sender, receiver_email, title, body, label, link, created_at, updated_at,
      updated_at as event_timestamp,
      -- define a new column event_type and set its value
      'is_update' as event_type
    from
      personal_notifications
    where
      personal_notifications.updated_at < :p1
      and receiver_email = :p2\\:\\:text
      and updated_at != created_at
    order by
      updated_at desc
    limit :p3\\:\\:int)
union (
  -- All rows.
  select
    personal_notification_id, sender, receiver_email, title, body, label, link, created_at, updated_at,
    created_at as event_timestamp,
    -- define a new column event_type and set its value
    'is_create' as event_type
  from
    personal_notifications
  where
    personal_notifications.created_at < :p1
    and receiver_email = :p2
  order by
    created_at desc
  limit :p3\\:\\:int)) as notifications
order by
  event_timestamp desc
limit :p3\\:\\:int
"""


class GetPersonalNotificationsByStartingDateParams(pydantic.BaseModel):
    starting_date: datetime.datetime
    receiver_email: str
    page_chunk_size: Optional[int]


class GetPersonalNotificationsByStartingDateRow(pydantic.BaseModel):
    personal_notification_id: int
    sender: Optional[str]
    receiver_email: str
    title: str
    label: str
    link: Optional[str]
    body: str
    created_at: datetime.datetime
    updated_at: datetime.datetime
    event_timestamp: datetime.datetime
    event_type: models.EventType
    row_number: int


class AsyncQuerier:
    def __init__(self, conn: sqlalchemy.ext.asyncio.AsyncConnection):
        self._conn = conn

    async def check_has_new_personal_notifications(self, *, receiver_email: str) -> Optional[bool]:
        row = (await self._conn.execute(sqlalchemy.text(CHECK_HAS_NEW_PERSONAL_NOTIFICATIONS), {"p1": receiver_email})).first()
        if row is None:
            return None
        return row[0]

    async def create_personal_notification(self, arg: CreatePersonalNotificationParams) -> Optional[models.PersonalNotification]:
        row = (await self._conn.execute(sqlalchemy.text(CREATE_PERSONAL_NOTIFICATION), {
            "p1": arg.sender,
            "p2": arg.receiver_email,
            "p3": arg.title,
            "p4": arg.body,
            "p5": arg.label,
            "p6": arg.link,
        })).first()
        if row is None:
            return None
        return models.PersonalNotification(
            personal_notification_id=row[0],
            sender=row[1],
            receiver_email=row[2],
            title=row[3],
            body=row[4],
            label=row[5],
            link=row[6],
            created_at=row[7],
            updated_at=row[8],
        )

    async def delete_personal_notification(self, *, personal_notification_id: int) -> None:
        await self._conn.execute(sqlalchemy.text(DELETE_PERSONAL_NOTIFICATION), {"p1": personal_notification_id})

    async def get_personal_notification_by_id(self, *, personal_notification_id: int) -> Optional[models.PersonalNotification]:
        row = (await self._conn.execute(sqlalchemy.text(GET_PERSONAL_NOTIFICATION_BY_ID), {"p1": personal_notification_id})).first()
        if row is None:
            return None
        return models.PersonalNotification(
            personal_notification_id=row[0],
            sender=row[1],
            receiver_email=row[2],
            title=row[3],
            body=row[4],
            label=row[5],
            link=row[6],
            created_at=row[7],
            updated_at=row[8],
        )

    async def get_personal_notifications_by_starting_date(self, arg: GetPersonalNotificationsByStartingDateParams) -> AsyncIterator[GetPersonalNotificationsByStartingDateRow]:
        result = await self._conn.stream(sqlalchemy.text(GET_PERSONAL_NOTIFICATIONS_BY_STARTING_DATE), {"p1": arg.starting_date, "p2": arg.receiver_email, "p3": arg.page_chunk_size})
        async for row in result:
            yield GetPersonalNotificationsByStartingDateRow(
                personal_notification_id=row[0],
                sender=row[1],
                receiver_email=row[2],
                title=row[3],
                label=row[4],
                link=row[5],
                body=row[6],
                created_at=row[7],
                updated_at=row[8],
                event_timestamp=row[9],
                event_type=row[10],
                row_number=row[11],
            )
