// Code generated by sqlc. DO NOT EDIT.
// source: users.sql

package db

import (
	"context"
	"time"
)

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT
  id, username, email, role, is_verified, salt, password, is_active, is_superuser, last_notification_at, created_at, updated_at
FROM
  "users"
WHERE
  "email" = $1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (Users, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i Users
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.Role,
		&i.IsVerified,
		&i.Salt,
		&i.Password,
		&i.IsActive,
		&i.IsSuperuser,
		&i.LastNotificationAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserById = `-- name: GetUserById :one
SELECT
  id, username, email, role, is_verified, salt, password, is_active, is_superuser, last_notification_at, created_at, updated_at
FROM
  "users"
WHERE
  "id" = $1
`

func (q *Queries) GetUserById(ctx context.Context, id int32) (Users, error) {
	row := q.db.QueryRow(ctx, getUserById, id)
	var i Users
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.Role,
		&i.IsVerified,
		&i.Salt,
		&i.Password,
		&i.IsActive,
		&i.IsSuperuser,
		&i.LastNotificationAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByUsername = `-- name: GetUserByUsername :one
SELECT
  id, username, email, role, is_verified, salt, password, is_active, is_superuser, last_notification_at, created_at, updated_at
FROM
  "users"
WHERE
  "username" = $1
`

func (q *Queries) GetUserByUsername(ctx context.Context, username string) (Users, error) {
	row := q.db.QueryRow(ctx, getUserByUsername, username)
	var i Users
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.Role,
		&i.IsVerified,
		&i.Salt,
		&i.Password,
		&i.IsActive,
		&i.IsSuperuser,
		&i.LastNotificationAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listAllNonVerifiedUsers = `-- name: ListAllNonVerifiedUsers :many
SELECT
  id, username, email, role, is_verified, salt, password, is_active, is_superuser, last_notification_at, created_at, updated_at
FROM
  "users"
WHERE
  "is_verified" = 'false'
`

func (q *Queries) ListAllNonVerifiedUsers(ctx context.Context) ([]Users, error) {
	rows, err := q.db.Query(ctx, listAllNonVerifiedUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Users{}
	for rows.Next() {
		var i Users
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Email,
			&i.Role,
			&i.IsVerified,
			&i.Salt,
			&i.Password,
			&i.IsActive,
			&i.IsSuperuser,
			&i.LastNotificationAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAllUsers = `-- name: ListAllUsers :many
SELECT
  id, username, email, role, is_verified, salt, password, is_active, is_superuser, last_notification_at, created_at, updated_at
FROM
  "users"
`

func (q *Queries) ListAllUsers(ctx context.Context) ([]Users, error) {
	rows, err := q.db.Query(ctx, listAllUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Users{}
	for rows.Next() {
		var i Users
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Email,
			&i.Role,
			&i.IsVerified,
			&i.Salt,
			&i.Password,
			&i.IsActive,
			&i.IsSuperuser,
			&i.LastNotificationAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const registerAdmin = `-- name: RegisterAdmin :one
INSERT INTO "users" ("username", "email", "password", "salt", "is_superuser", "is_verified")
  VALUES ($1, $2, $3, $4, TRUE, TRUE)
RETURNING
  id, username, email, role, is_verified, salt, password, is_active, is_superuser, last_notification_at, created_at, updated_at
`

type RegisterAdminParams struct {
	Username string `db:"username"`
	Email    string `db:"email"`
	Password string `db:"password"`
	Salt     string `db:"salt"`
}

func (q *Queries) RegisterAdmin(ctx context.Context, arg RegisterAdminParams) (Users, error) {
	row := q.db.QueryRow(ctx, registerAdmin,
		arg.Username,
		arg.Email,
		arg.Password,
		arg.Salt,
	)
	var i Users
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.Role,
		&i.IsVerified,
		&i.Salt,
		&i.Password,
		&i.IsActive,
		&i.IsSuperuser,
		&i.LastNotificationAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const registerNewUser = `-- name: RegisterNewUser :one
INSERT INTO "users" ("username", "email", "password", "salt")
  VALUES ($1, $2, $3, $4)
RETURNING
  id, username, email, role, is_verified, salt, password, is_active, is_superuser, last_notification_at, created_at, updated_at
`

type RegisterNewUserParams struct {
	Username string `db:"username"`
	Email    string `db:"email"`
	Password string `db:"password"`
	Salt     string `db:"salt"`
}

func (q *Queries) RegisterNewUser(ctx context.Context, arg RegisterNewUserParams) (Users, error) {
	row := q.db.QueryRow(ctx, registerNewUser,
		arg.Username,
		arg.Email,
		arg.Password,
		arg.Salt,
	)
	var i Users
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.Role,
		&i.IsVerified,
		&i.Salt,
		&i.Password,
		&i.IsActive,
		&i.IsSuperuser,
		&i.LastNotificationAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const registerVerifiedUser = `-- name: RegisterVerifiedUser :one
INSERT INTO "users" ("username", "email", "password", "salt", "is_verified")
  VALUES ($1, $2, $3, $4, TRUE)
RETURNING
  id, username, email, role, is_verified, salt, password, is_active, is_superuser, last_notification_at, created_at, updated_at
`

type RegisterVerifiedUserParams struct {
	Username string `db:"username"`
	Email    string `db:"email"`
	Password string `db:"password"`
	Salt     string `db:"salt"`
}

func (q *Queries) RegisterVerifiedUser(ctx context.Context, arg RegisterVerifiedUserParams) (Users, error) {
	row := q.db.QueryRow(ctx, registerVerifiedUser,
		arg.Username,
		arg.Email,
		arg.Password,
		arg.Salt,
	)
	var i Users
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.Role,
		&i.IsVerified,
		&i.Salt,
		&i.Password,
		&i.IsActive,
		&i.IsSuperuser,
		&i.LastNotificationAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const resetUserPassword = `-- name: ResetUserPassword :one
UPDATE
  "users"
SET
  "password" = $1,
  "salt" = $2
WHERE
  "email" = $3
RETURNING
  id, username, email, role, is_verified, salt, password, is_active, is_superuser, last_notification_at, created_at, updated_at
`

type ResetUserPasswordParams struct {
	Password string `db:"password"`
	Salt     string `db:"salt"`
	Email    string `db:"email"`
}

func (q *Queries) ResetUserPassword(ctx context.Context, arg ResetUserPasswordParams) (Users, error) {
	row := q.db.QueryRow(ctx, resetUserPassword, arg.Password, arg.Salt, arg.Email)
	var i Users
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.Role,
		&i.IsVerified,
		&i.Salt,
		&i.Password,
		&i.IsActive,
		&i.IsSuperuser,
		&i.LastNotificationAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateLastNotificationAt = `-- name: UpdateLastNotificationAt :one
UPDATE
  "users"
SET
  "last_notification_at" = $1
WHERE
  "id" = $2
RETURNING
  id, username, email, role, is_verified, salt, password, is_active, is_superuser, last_notification_at, created_at, updated_at
`

type UpdateLastNotificationAtParams struct {
	LastNotificationAt time.Time `db:"last_notification_at"`
	ID                 int32     `db:"id"`
}

func (q *Queries) UpdateLastNotificationAt(ctx context.Context, arg UpdateLastNotificationAtParams) (Users, error) {
	row := q.db.QueryRow(ctx, updateLastNotificationAt, arg.LastNotificationAt, arg.ID)
	var i Users
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.Role,
		&i.IsVerified,
		&i.Salt,
		&i.Password,
		&i.IsActive,
		&i.IsSuperuser,
		&i.LastNotificationAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateUserById = `-- name: UpdateUserById :one
UPDATE
  "users"
SET
  "password" = CASE WHEN $1::boolean THEN
    $2
  ELSE
    "password"
  END,
  "salt" = CASE WHEN $3::boolean THEN
    $4
  ELSE
    "salt"
  END,
  "username" = CASE WHEN $5::boolean THEN
    $6
  ELSE
    "username"
  END,
  "email" = CASE WHEN $7::boolean THEN
    $8
  ELSE
    "email"
  END
WHERE
  "id" = $9
RETURNING
  id, username, email, role, is_verified, salt, password, is_active, is_superuser, last_notification_at, created_at, updated_at
`

type UpdateUserByIdParams struct {
	PasswordDoUpdate bool   `db:"password_do_update"`
	Password         string `db:"password"`
	SaltDoUpdate     bool   `db:"salt_do_update"`
	Salt             string `db:"salt"`
	UsernameDoUpdate bool   `db:"username_do_update"`
	Username         string `db:"username"`
	EmailDoUpdate    bool   `db:"email_do_update"`
	Email            string `db:"email"`
	ID               int32  `db:"id"`
}

func (q *Queries) UpdateUserById(ctx context.Context, arg UpdateUserByIdParams) (Users, error) {
	row := q.db.QueryRow(ctx, updateUserById,
		arg.PasswordDoUpdate,
		arg.Password,
		arg.SaltDoUpdate,
		arg.Salt,
		arg.UsernameDoUpdate,
		arg.Username,
		arg.EmailDoUpdate,
		arg.Email,
		arg.ID,
	)
	var i Users
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.Role,
		&i.IsVerified,
		&i.Salt,
		&i.Password,
		&i.IsActive,
		&i.IsSuperuser,
		&i.LastNotificationAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateUserRole = `-- name: UpdateUserRole :one
UPDATE
  "users"
SET
  "role" = $1
WHERE
  "id" = $2
RETURNING
  id, username, email, role, is_verified, salt, password, is_active, is_superuser, last_notification_at, created_at, updated_at
`

type UpdateUserRoleParams struct {
	Role string `db:"role"`
	ID   int32  `db:"id"`
}

func (q *Queries) UpdateUserRole(ctx context.Context, arg UpdateUserRoleParams) (Users, error) {
	row := q.db.QueryRow(ctx, updateUserRole, arg.Role, arg.ID)
	var i Users
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.Role,
		&i.IsVerified,
		&i.Salt,
		&i.Password,
		&i.IsActive,
		&i.IsSuperuser,
		&i.LastNotificationAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const verifyUserByEmail = `-- name: VerifyUserByEmail :one
UPDATE
  "users"
SET
  "is_verified" = 'true'
WHERE
  "email" = $1
RETURNING
  id, username, email, role, is_verified, salt, password, is_active, is_superuser, last_notification_at, created_at, updated_at
`

func (q *Queries) VerifyUserByEmail(ctx context.Context, email string) (Users, error) {
	row := q.db.QueryRow(ctx, verifyUserByEmail, email)
	var i Users
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.Role,
		&i.IsVerified,
		&i.Salt,
		&i.Password,
		&i.IsActive,
		&i.IsSuperuser,
		&i.LastNotificationAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
