# SQLC

## SELECT

- To avoid generating *_2, *_3 etc duplicate columns in struct with sqlc when there are multiple joins, 
  ensure to have the main SELECT get only what's actually needed. E.g.
```sql
  SELECT
    a_new_table.id,
    a_new_table.sender,
    a_new_table.receiver_role,
    a_new_table.label,
    ...
FROM (
  --long JOIN's and SELECT *'s from some table(s)
  ...
  )  AS a_new_table
```

## RETURNING clause

It is OK to use RETURNING * when it is a single table query, and SQLC will also return all rows by default in a struct so it's unnecessary to manually specify all columns to return and keep them up to date.
For any specific query that requires us to hide values or are unnecessary, then it may be better to do it in SQL and replace ``*`` with; or perhaps, define a specific ``*Create`` struct in the service itself, but modifying ``RETURNING ...`` is more advisable to have to it autogenerated every time. If we need some value that is hidden from the query, we can exec another query that does return that value.
Example: why return the whole user when we update a couple of columns only. Need an additional column for something else in a specific service? Query the whole user in that case then. Drawbacks?

# XO:

https://github.com/xo/xo

https://github.com/xo/xo/tree/master/_examples/booktest

## Notes on generated ``func (*) Insert``

For Postgres, it will detect when something is generated by the database. It will show something like:
```go
	// insert (primary key generated and returned by database)
```
nevertheless, the struct is the same for every query. Meaning, in the case of updates we have to get the full object and pass the one updated with rest of options untouched. Perhaps its better to have it the sqlc way? Worth the extra SQL query?
